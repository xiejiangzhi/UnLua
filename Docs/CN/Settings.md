# 设置

通过 `UnLua工具栏->设置` 打开，或者从 `项目设置-> 插件` 界面找到对应的选项卡。

## 一、运行时设置

### 启动模块名称

当Lua环境启动时，立即执行指定的脚本模块。例如此选项配置为 **Main** 时，将会执行 **Main.lua** 。留空则表示不执行任何脚本模块。

### 无限循环检测

设置一个超时时间（单位：秒），防止Lua代码陷入无限循环，导致游戏失去响应。默认为0秒（不启用）

注：检测基于 Lua Hook API ，因此只能防止Lua虚拟机在执行字节码时的无限循环，如果执行发生在C++层则依然会卡死。

### Lua环境分配器

默认的分配器会将所有 `UObject` 都分配到同一个Lua环境里，这通常适用于绝大部分的应用场景。

但有时候我们可能会有环境隔离的需求，比如将同一个 `GameInstance` 下的所有对象放在同一个环境里，在游戏退出时一次性释放所有该游戏实例相关的资源。又或者一些Lua游戏UI框架没有为单进程多游戏实例设计，在单进程启动多个游戏实例时会出现对象冲突的问题，此时就可以选择使用 `ULuaEnvLocator_ByGameInstance` 来做好相互隔离。

你也可以继承 `ULuaEnvLocator` 来实现自己的分配逻辑，但要注意的是，隔离并不是沙箱，它们依然可以通过UE接口访问到其它环境中的对象。

### Lua模块定位器

默认在绑定对象到Lua时，生成的 `GetModuleName` 需要手动填入绑定模块路径，或者按住`Alt`来根据蓝图资源路径来自动填充。

如果期望建立自己的绑定规则，比如所有 `Content/Blueprints` 目录下所有的蓝图都直接绑定到 `Content/Script` 下同名的Lua脚本，或者剔除掉脚本名的 `BP_` 前缀等等。

针对这类需求，可以继承 `ULuaModuleLocator` 来实现自己的自动绑定规则。如此一来，也可以避免不确定哪些蓝图绑定了哪些脚本的情形，更便于管理。

## 二、编辑器设置

### 热重载模式

- 自动：在代码发生变更时立即重载
- 手动：通过快捷键 `Alt+L` 或工具栏 `热重载` 菜单选项触发热重载
- 永不：禁用热重载机制

### 生成智能提示信息

是否为Lua生成智能提示信息，使用流程参考[这里](IntelliSense.md)

### 自动启动

默认UnLua模块会随着游戏启动自动开启，以便捕获到所有可绑定的对象。但有时候可能会有自己的游戏启动流程，可以关闭这个选项，在合适的时机通过`UnLua::Startup()` 来启动。

*注：重启编译后生效*

### 启用UnLua调试代码

打开这个选项以获得UnLua相关的更详细的调试信息，默认关闭。

*注：重启编译后生效*

### 启用UFunction调用参数持久化缓存

为每个UFunction创建一个缓存块，每次进行UE和Lua交互调用时，重用这块内存，节省反复分配/释放内存的开销，默认启用。

*注：重启编译后生效*

### 启用类型检查

在每次Lua调用UE时进行参数类型检查，建议本地开发时启用，游戏测试/发布时关闭以获得更好的性能，默认开启。

*注：重启编译后生效*

### 启用RPC调用支持

默认开启，关闭后会默认所有覆盖的函数调用为本地调用，并对Out参数预留缓存，以获得这类函数调用的少许性能提升。如果你的游戏使用了联机特性建议不要关闭这个选项。

*已过时：这个选项将在未来版本中移除。*

*注：重启编译后生效*

### 启用被覆写函数调用支持

默认开启，使得我们在Lua中可以使用 `self.Overridden` 来访问被覆写的原函数。

*注：重启编译后生效*

### 使用C++编译Lua环境

默认关闭，开启以得到更正确的跨语言交互异常处理支持，但需要手动处理以C编译的第三方库源码依赖Lua的符号问题。

*注：重启编译后生效*

### UE4命名空间

兼容旧版本需要通过 `UE4` 来访问的代码（新版中为 `UE`）。

*注：重启编译后生效*

### 返回值顺序

兼容旧版本需要把Out参数放在返回值前面的代码。

*注：重启编译后生效*

### 蓝图资源路径后缀

兼容旧版本中加载蓝图资源时，需要自动在路径末尾补 `_C` 的代码。

*注：重启编译后生效*

### 检查新版本

当发现新版本时，会在控制台输出新版本信息。